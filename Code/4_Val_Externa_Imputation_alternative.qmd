---
title: "4 Codigo Reproducible: Rendimiento de Validacion Externa de ecuaciones originales - Recalibración de modelo KFRE para predecir falla renal en asegurados de EsSalud"
author: "Percy Soto Becerra"
format: 
  html:
   theme: cerulean
   toc: true
   number-sections: true
   df-print: paged
   page-layout: full
   embed-resources: true
   code-fold: true
execute: 
  warning: false
  message: false
---

## Introduction 

This document presents the code and results of the main analysis shown in the article.

## Setup

```{r}
#| label: load-packages
#| include: true

rm(list = ls())

# Use pacman to check whether packages are installed, if not load
if (!require("pacman")) install.packages("pacman")
library(pacman)

# Unload all package to begin in a session with only base packages
pacman::p_unload(all)

# Install packages
pacman::p_load(
  here, 
  skimr, 
  survival,
  survminer, 
  rms,
  cmprsk,
  riskRegression,
  mstate,
  pseudo,
  pec,
  plotrix,
  knitr,
  splines,
  kableExtra,
  flextable,
  gtsummary,
  boot,
  tidyverse,
  rsample,
  gridExtra,
  webshot, 
  patchwork,
  survival, 
  ggsci, 
  cowplot, 
  scales, 
  patchwork, 
  labelled, 
  glue, 
  dcurves, 
  broom, 
  downlit, 
  xml2, 
  gghalves, 
  devtools, 
  htmltools, 
  gghalves, 
  ggtext, 
  DiagrammeR, 
  gt, 
  janitor, 
  VIM, 
  PerformanceAnalytics, 
  mice, 
  rms, 
  naniar, 
  DescTools, 
  gtools, 
  ggExtra, 
  furrr, 
  future, 
  ggmice,
  parallel,
  tictoc, 
  rio,
  tidymodels
)

if (!require("impstep")) remotes::install_github("bgravesteijn/impstep", force = TRUE)
if (!require("smplot2")) devtools::install_github('smin95/smplot2', force = TRUE)
# You will need Rtools to install packages from Github on Windows
# `devtools` with throw an informative error if Rtools is not found
# if (!"devtools" %in% installed.packages()) install.packages("devtools")
# if (!require("smplot2")) devtools::install_github("jesse-smith/futuremice")

library(impstep)

## Revisar:; https://amices.org/ggmice/index.html
```

## Cargar datos

```{r}
# Import data
data_impA <- readRDS(here::here("Data", "Tidy", "data_impA.rds")) 
imp.datosA <- complete(data_impA, action = "long", include = TRUE)
rm(data_impA)
gc()
```

## Cargar funciones

```{r}
source(here("Code", "source", "kfre_pi.R"))
source(here("Code", "source", "kfre_pr.R"))
source(here("Code", "source", "oe_ratio.R"))
source(here("Code", "source", "calibration_intercept.R"))
source(here("Code", "source", "calibration_slope.R"))
source(here("Code", "source", "auc.R"))
source(here("Code", "source", "auc_brier_boot.R"))
source(here("Code", "source", "validate.mids.R"))
source(here("Code", "source", "pool.validate.mids.R"))
source(here("Code", "source", "pool.auc.mids.R"))
source(here("Code", "source", "process_imp_cal_plot.R"))
source(here("Code", "source", "predict.mira.R"))
source(here("Code", "source", "performance_measures.R"))
```


## Configurar cores para parallel processing

```{r}
n_cores <- detectCores()
n_cores

# Evaluate futures in parallel - max of two workers to avoid hogging resources
future::plan("multisession", workers = n_cores-2)
```
## Pre-procesar

```{r}
imp.datosA <- imp.datosA |> 
  mutate(risk2y = kfre_pr(imp.datosA, 2),
         risk5y = kfre_pr(imp.datosA, 5)) |> 
  select(.imp, .id, time, eventd, risk2y, risk5y)
```


## Predictive Performance

### Calibration and Discrimination Measures

```{r}
imp.datosA <- imp.datosA |> 
  filter(.imp != 0) |> 
  mutate(eventdf = factor(eventd))

datos <- imp.datosA |> 
  filter(.imp == 1) 

datos2 <- imp.datosA |> 
  filter(.imp <= 3) 
```


```{r}
performance_measures(datos, 2, 1, "risk2y")
```

```{r}
resultados <- datos2 %>%
  group_by(.imp) %>%
  nest() %>%
  mutate(performance = future_map(data, ~ performance_measures(
    data = .x,
    horizon = 2,  
    primary_event = 1,  
    pred = "risk2y"),    
    .options = furrr_options(
      seed = 123, 
      packages = c("riskRegression", 
                   "survival", 
                   "splines", 
                   "cmprsk",
                   "tidyverse", 
                   "prodlim",
                   "geepack")), 
    .progress = TRUE)) 
```


```{r}
resultados <- datos2 %>%
  group_by(.imp) %>%
  summarise(performance = list(future_map(
    .x = list(cur_data()),  # Pasar los datos del grupo actual como lista para future_map
    .f = ~ performance_measures(
      data = .x,
      horizon = 2,
      primary_event = 1,
      pred = "risk2y"
    ),
    .options = furrr_options(
      seed = 123,
      packages = c("riskRegression", "survival", "splines", "cmprsk", "tidyverse", "prodlim", "geepack")
    )
  )), .groups = 'drop') %>% 
  mutate(performance = map(performance, `[[`, 1))  # Extrae el resultado de la lista para cada imputación

# Asegúrate de que el resultado está como esperas
glimpse(resultados)
```


```{r}
imp.datosA |> 
  mutate(results = future_map(.imp, 
                              performance_measures, 
                              horizon = 2, 
                              primary_event = 1, 
                              pred = "risk2y",    
                              .options = furrr_options(
                                seed = 123, 
                                packages = c("riskRegression", 
                                             "survival", 
                                             "splines", 
                                             "cmprsk",
                                             "tidyverse", 
                                             "prodlim",
                                             "geepack")), 
                              .progress = TRUE))
```


```{r}
tic()
bootdf <- bootstraps(imp.datosA, times = 10, 
                     strata = .imp, 
                     apparent = TRUE) |> 
  mutate(results = future_map(splits, 
                              auc_brier_boot, 
                              horizon = 2, 
                              primary_event = 1, 
                              pred = "risk2y",                            
                              .options = furrr_options(
                                seed = 123, 
                                packages = c("riskRegression", 
                                             "survival", 
                                             "splines", 
                                             "cmprsk",
                                             "tidyverse", 
                                             "prodlim")), 
                              .progress = TRUE))
toc()
```
```{r}
int_pctl(bootdf, results)
```


```{r}
# Grupo 3a-3b-4 2 anios---------------------------------------------------------
horizon <- 2
primary_event <- 1

auc_measure <- validate.mids(data_impA, kfre_pr, auc, "auc", alpha = 0.05, 
                             horizon = horizon, primary_event = primary_event)
cal_int_measure <- validate.mids(data_impA, kfre_pr, calibration_intercept, 
                                 "calibration_intercept", alpha = 0.05, 
                                 horizon = horizon, primary_event = primary_event)
cal_slope_measure <- validate.mids(data_impA, kfre_pr, calibration_slope, 
                                   "calibration_slope", alpha = 0.05, 
                                   horizon = horizon, primary_event = primary_event)
oe_ratio_measure <- validate.mids(data_impA, kfre_pr, oe_ratio, 
                                   "oe_ratio", alpha = 0.05, 
                                   horizon = horizon, primary_event = primary_event)
## Average predicted risk
imp.datosA |> 
  mutate(pred = kfre_pr(imp.datosA, horizon)) |> 
  filter(.imp != 0) |> 
  summarise(avg_pred = mean(pred)) |> 
  pull(avg_pred) -> avg_pred

## Average observed proportion
avg_obs_imp <- rep(NA, max(imp.datosA$.imp))

for (i in seq_len(max(imp.datosA$.imp))) {
  datos_filtered <- imp.datosA |> 
    filter(.imp == i) 
  
  obj <- summary(survfit(Surv(time5y, eventd5ylab) ~ 1, data = datos_filtered ), times = horizon)
  avg_obs <- obj$pstate[, primary_event + 1]
  avg_obs_imp[i] <- avg_obs
}

avg_obs <- mean(avg_obs_imp)

## Other measures
oe_ratio_res <- pool.validate.mids(oe_ratio_measure)
cal_int_res <- pool.validate.mids(cal_int_measure)
cal_slope_res <- pool.validate.mids(cal_slope_measure)
auc_res <- pool.validate.mids(auc_measure)

## Table of results
datos_res1 <- data.frame(
  measures = c("Average predicted risk", "Average observed proportion", 
               "O/E ratio (95% CI)", "Calibration intercept (95% CI)", 
               "Calibration Slope (95% CI)", "C-index up to t-years (95% CI)"),
  estimates = c(100 * avg_pred, 100 * avg_obs, 
                oe_ratio_res[["pooled"]][["estimate"]], 
                cal_int_res[["pooled"]][["estimate"]], 
                cal_slope_res[["pooled"]][["estimate"]], 
                auc_res[["pooled"]][["estimate"]]), 
  ci.lb = c(NA, NA, oe_ratio_res[["pooled"]][["ci.lb"]], 
            cal_int_res[["pooled"]][["ci.lb"]], 
            cal_slope_res[["pooled"]][["ci.lb"]], 
            auc_res[["pooled"]][["ci.lb"]]),
  ci.ub = c(NA, NA, oe_ratio_res[["pooled"]][["ci.ub"]], 
            cal_int_res[["pooled"]][["ci.ub"]], 
            cal_slope_res[["pooled"]][["ci.ub"]], 
            auc_res[["pooled"]][["ci.ub"]])
  ) |> 
  mutate(res = str_glue("{round(estimates, 2)} ({round(ci.lb, 2)} to {round(ci.ub, 2)})")) |> 
  select(measures, res)

# Grupo 3a-3b-4 5 anios---------------------------------------------------------
horizon <- 5
primary_event <- 1
auc_measure <- validate.mids(data_impA, kfre_pr, auc, "auc", alpha = 0.05, 
                             horizon = horizon, primary_event = primary_event)
cal_int_measure <- validate.mids(data_impA, kfre_pr, calibration_intercept, 
                                 "calibration_intercept", alpha = 0.05, 
                                 horizon = horizon, primary_event = primary_event)
cal_slope_measure <- validate.mids(data_impA, kfre_pr, calibration_slope, 
                                   "calibration_slope", alpha = 0.05, 
                                   horizon = horizon, primary_event = primary_event)
oe_ratio_measure <- validate.mids(data_impA, kfre_pr, oe_ratio, 
                                  "oe_ratio", alpha = 0.05, 
                                  horizon = horizon, primary_event = primary_event)

## Average predicted risk
imp.datosA |> 
  mutate(pred = kfre_pr(imp.datosA, 5)) |> 
  filter(.imp != 0) |> 
  summarise(avg_pred = mean(pred)) |> 
  pull(avg_pred) -> avg_pred

## Average observed proportion
avg_obs_imp <- rep(NA, max(imp.datosA$.imp))

for (i in seq_len(max(imp.datosA$.imp))) {
  datos_filtered <- imp.datosA |> 
    filter(.imp == i) 
  
  obj <- summary(survfit(Surv(time5y, eventd5ylab) ~ 1, data = datos_filtered ), times = horizon)
  avg_obs <- obj$pstate[, primary_event + 1]
  avg_obs_imp[i] <- avg_obs
}

avg_obs <- mean(avg_obs_imp)

oe_ratio_res <- pool.validate.mids(oe_ratio_measure)
cal_int_res <- pool.validate.mids(cal_int_measure)
cal_slope_res <- pool.validate.mids(cal_slope_measure)
auc_res <- pool.validate.mids(auc_measure)

datos_res2 <- data.frame(
  measures = c("Average predicted risk", "Average observed proportion", 
               "O/E ratio (95% CI)", "Calibration intercept (95% CI)", 
               "Calibration Slope (95% CI)", "C-index up to t-years (95% CI)"),
  estimates = c(100 * avg_pred, 100 * avg_obs, 
                oe_ratio_res[["pooled"]][["estimate"]], 
                cal_int_res[["pooled"]][["estimate"]], 
                cal_slope_res[["pooled"]][["estimate"]], 
                auc_res[["pooled"]][["estimate"]]), 
  ci.lb = c(NA, NA, oe_ratio_res[["pooled"]][["ci.lb"]], 
                cal_int_res[["pooled"]][["ci.lb"]], 
                cal_slope_res[["pooled"]][["ci.lb"]], 
                auc_res[["pooled"]][["ci.lb"]]),
  ci.ub = c(NA, NA, oe_ratio_res[["pooled"]][["ci.ub"]], 
                cal_int_res[["pooled"]][["ci.ub"]], 
                cal_slope_res[["pooled"]][["ci.ub"]], 
                auc_res[["pooled"]][["ci.ub"]])
) |> 
  mutate(res = str_glue("{round(estimates, 2)} ({round(ci.lb, 2)} to {round(ci.ub, 2)})")) |> 
  select(measures, res)

# Grupo 3b-4 2 anios---------------------------------------------------------
horizon <- 2
primary_event <- 1

auc_measure <- validate.mids(data_impB, kfre_pr, auc, "auc", alpha = 0.05, 
                             horizon = horizon, primary_event = primary_event)
cal_int_measure <- validate.mids(data_impB, kfre_pr, calibration_intercept, 
                                 "calibration_intercept", alpha = 0.05, 
                                 horizon = horizon, primary_event = primary_event)
cal_slope_measure <- validate.mids(data_impB, kfre_pr, calibration_slope, 
                                   "calibration_slope", alpha = 0.05, 
                                   horizon = horizon, primary_event = primary_event)
oe_ratio_measure <- validate.mids(data_impB, kfre_pr, oe_ratio, 
                                   "oe_ratio", alpha = 0.05, 
                                   horizon = horizon, primary_event = primary_event)

## Average predicted risk
imp.datosB |> 
  mutate(pred = kfre_pr(imp.datosB, 2)) |> 
  filter(.imp != 0) |> 
  summarise(avg_pred = mean(pred)) |> 
  pull(avg_pred) -> avg_pred

## Average observed proportion

avg_obs_imp <- rep(NA, max(imp.datosB$.imp))

for (i in seq_len(max(imp.datosB$.imp))) {
  datos_filtered <- imp.datosB |> 
    filter(.imp == i) 
  
  obj <- summary(survfit(Surv(time5y, eventd5ylab) ~ 1, data = datos_filtered ), times = horizon)
  avg_obs <- obj$pstate[, primary_event + 1]
  avg_obs_imp[i] <- avg_obs
}

avg_obs <- mean(avg_obs_imp)

oe_ratio_res <- pool.validate.mids(oe_ratio_measure)
cal_int_res <- pool.validate.mids(cal_int_measure)
cal_slope_res <- pool.validate.mids(cal_slope_measure)
auc_res <- pool.validate.mids(auc_measure)

datos_res3 <- data.frame(
  measures = c("Average predicted risk", "Average observed proportion", 
               "O/E ratio (95% CI)", "Calibration intercept (95% CI)", 
               "Calibration Slope (95% CI)", "C-index up to t-years (95% CI)"),
  estimates = c(100 * avg_pred, 100 * avg_obs, 
                oe_ratio_res[["pooled"]][["estimate"]], 
                cal_int_res[["pooled"]][["estimate"]], 
                cal_slope_res[["pooled"]][["estimate"]], 
                auc_res[["pooled"]][["estimate"]]), 
  ci.lb = c(NA, NA, oe_ratio_res[["pooled"]][["ci.lb"]], 
                cal_int_res[["pooled"]][["ci.lb"]], 
                cal_slope_res[["pooled"]][["ci.lb"]], 
                auc_res[["pooled"]][["ci.lb"]]),
  ci.ub = c(NA, NA, oe_ratio_res[["pooled"]][["ci.ub"]], 
                cal_int_res[["pooled"]][["ci.ub"]], 
                cal_slope_res[["pooled"]][["ci.ub"]], 
                auc_res[["pooled"]][["ci.ub"]])
) |> 
  mutate(res = str_glue("{round(estimates, 2)} ({round(ci.lb, 2)} to {round(ci.ub, 2)})")) |> 
  select(measures, res)

# Grupo 3b-4 5 anios---------------------------------------------------------
horizon <- 5
primary_event <- 1
auc_measure <- validate.mids(data_impB, kfre_pr, auc, "auc", alpha = 0.05, 
                             horizon = horizon , primary_event = primary_event)
cal_int_measure <- validate.mids(data_impB, kfre_pr, calibration_intercept, 
                                 "calibration_intercept", alpha = 0.05, 
                                 horizon = horizon , primary_event = primary_event)
cal_slope_measure <- validate.mids(data_impB, kfre_pr, calibration_slope, 
                                   "calibration_slope", alpha = 0.05, 
                                   horizon = horizon , primary_event = primary_event)
oe_ratio_measure <- validate.mids(data_impB, kfre_pr, oe_ratio, 
                                   "oe_ratio", alpha = 0.05, 
                                   horizon = horizon , primary_event = primary_event)


## Average predicted risk
imp.datosB |> 
  mutate(pred = kfre_pr(imp.datosB, 5)) |> 
  filter(.imp != 0) |> 
  summarise(avg_pred = mean(pred)) |> 
  pull(avg_pred) -> avg_pred

## Average observed proportion
avg_obs_imp <- rep(NA, max(imp.datosB$.imp))

for (i in seq_len(max(imp.datosB$.imp))) {
  datos_filtered <- imp.datosB |> 
    filter(.imp == i) 
  
  obj <- summary(survfit(Surv(time5y, eventd5ylab) ~ 1, data = datos_filtered ), times = horizon)
  avg_obs <- obj$pstate[, primary_event + 1]
  avg_obs_imp[i] <- avg_obs
}

avg_obs <- mean(avg_obs_imp)

oe_ratio_res <- pool.validate.mids(oe_ratio_measure)
cal_int_res <- pool.validate.mids(cal_int_measure)
cal_slope_res <- pool.validate.mids(cal_slope_measure)
auc_res <- pool.validate.mids(auc_measure)

datos_res4 <- data.frame(
  measures = c("Average predicted risk", "Average observed proportion", 
               "O/E ratio (95% CI)", "Calibration intercept (95% CI)", 
               "Calibration Slope (95% CI)", "C-index up to t-years (95% CI)"),
  estimates = c(100 * avg_pred, 100 * avg_obs, 
                oe_ratio_res[["pooled"]][["estimate"]], 
                cal_int_res[["pooled"]][["estimate"]], 
                cal_slope_res[["pooled"]][["estimate"]], 
                auc_res[["pooled"]][["estimate"]]), 
  ci.lb = c(NA, NA, oe_ratio_res[["pooled"]][["ci.lb"]], 
                cal_int_res[["pooled"]][["ci.lb"]], 
                cal_slope_res[["pooled"]][["ci.lb"]], 
                auc_res[["pooled"]][["ci.lb"]]),
  ci.ub = c(NA, NA, oe_ratio_res[["pooled"]][["ci.ub"]], 
                cal_int_res[["pooled"]][["ci.ub"]], 
                cal_slope_res[["pooled"]][["ci.ub"]], 
                auc_res[["pooled"]][["ci.ub"]])
) |> 
  mutate(res = str_glue("{round(estimates, 2)} ({round(ci.lb, 2)} to {round(ci.ub, 2)})")) |> 
  select(measures, res)
```


```{r}
# Tabla final
table_perf_final <- datos_res1 |> 
  left_join(datos_res2, by = "measures") |> 
  left_join(datos_res3, by = "measures") |> 
  left_join(datos_res4, by = "measures") |> 
  mutate(grupo = c(rep("Calibration", 5), "Discrimination")) |> 
  as_grouped_data(groups = "grupo") |> 
  flextable::as_flextable(hide_grouplabel = TRUE) |> 
  set_header_labels(
    measures = "Validation aspect and performance measure", 
    res.x = "t = 2 year", 
    res.y = "t = 5 year", 
    res.x.x = "t = 2 year", 
    res.y.y = "t = 5 year" 
  ) %>% 
  add_header_row(
    values = c("Validation aspect and performance measure", "CKD Stages 3a-3b-4", "CKD Stages 3b-4"), 
    colwidths = c(1, 2, 2)
  ) %>% 
  merge_v(j = 1, part = "header") %>% 
  bold(i = c(1, 7)) %>% 
  autofit()  %>% 
  set_caption("Table 2. Performance measures of KFRE in the external dataset of patients with CKD Stages 3a-4 and 3b-4") %>% 
  theme_booktabs() %>%  
  bold(bold = TRUE, part = "header") 

table_perf_final %>% 
  flextable::save_as_docx(path = here("Tables/Table_Imputed_Performance.docx"))

table_perf_final
```

```{r}
rm(list = c("data_impA", "data_impB", "dataA", "dataB"))
gc()
```

### Moderate calibration: Calibration curves lowess based on subdistributional hazards

```{r}
#| label: rcs-pseudo

primary_event <- 1

# Seleccion del grupo: Stages 3-4----

# A 2 años----
horizon <- 2

vdata <- imp.datosA %>% 
  mutate(risk2y = kfre_pr(imp.datosA, horizon = 2), 
         risk5y = kfre_pr(imp.datosA, horizon = 5)) |> 
  select(.imp, .id, risk2y, risk5y, time5y, eventd5y, time, eventd) |> 
  mutate(pred = risk2y) |> 
  select(.imp, .id, time, eventd, pred) |> 
  mutate(cll_pred = log(-log(1 - pred)))

subdist_list <- future_map(1:max(vdata$.imp),
                           process_imp_cal_plot, 
                           vdata = vdata, 
                           primary_event = primary_event, 
                           horizon = horizon, 
                           type = "subdist_hazard", 
                           n_internal_knots = 5,
                           .options = furrr_options(seed = 123, 
                                                    packages = c("riskRegression", 
                                                                 "survival", 
                                                                 "splines", 
                                                                 "cmprsk",
                                                                 "tidyverse")), 
                           .progress = TRUE)

subdist_df <- bind_rows(subdist_list) |>  
  filter(.imp != 0) |> 
  arrange(.imp, .id)

rio::export(subdist_df, here("Data", "Tidy", "subdist_df_3a4_2y.rds"))

# 5 knots seems to give somewhat equivalent graph to pseudo method with bw = 0.05
vdata_stack <- vdata |> 
  filter(.imp != 0)

n_internal_knots <- 5

rcs_vdata <- ns(vdata_stack$cll_pred, df = n_internal_knots + 1)

colnames(rcs_vdata) <- paste0("basisf_", colnames(rcs_vdata))
# vdata_bis <- cbind.data.frame(vdata_filt, rcs_vdata)

vdata_stack <- vdata_stack |> 
  bind_cols(as.data.frame(rcs_vdata))

# Use subdistribution hazards (Fine-Gray) model
form_fgr <- reformulate(
  termlabels = colnames(rcs_vdata),
  response = "Hist(time, eventd)")
```

```{r}
rm(list=ls()[! ls() %in% c("imp.datosA","vdata_stack", "imp.datosB", 
                           "n_internal_knots", "rcs_vdata", "form_fgr",  
                           "primary_event", "horizon")])
gc()
```


```{r}
# Regress subdistribution of event of interest on cloglog of estimated risks
calib_fgr <- FGR(
  formula = form_fgr,
  cause = primary_event,
  data = vdata_stack, 
  variance = FALSE
)
```

```{r}
export(calib_fgr, here("Code", "source", "calib_fgr_3a4_2y.rds"))
```

```{r}
obs <- predict(calib_fgr, times = horizon, newdata = vdata_stack)
```


```{r}
subdist_df2 <- vdata_stack |>
   mutate(obs_stack = obs, 
          risk = pred, 
          deciles_risk = quantcut(risk, seq(0, 1, by = 0.1)))

# Crea datos con predicciones agrupadas por deciles
subdist_df_dec <- subdist_df2 |>
  group_by(deciles_risk) |>
  summarize(
    risk_dec = mean(risk),
    obs_dec = mean(obs_stack))

# Grafico de calibracion
ggplot() +
  geom_abline(intercept = 0, slope = 1, colour = "red", linetype = 2) + 
  geom_line(data = subdist_df |> arrange(risk),
            aes(x = risk, y = obs, group = .imp),
            alpha = 0.1, color = "#38B8F7") +
  geom_line(data = subdist_df2 |> arrange(risk),
            aes(x = risk, y = obs_stack),
            alpha = 1, color = "blue") +
  geom_point(data = subdist_df |> arrange(risk), 
             aes(x = risk, y = obs), 
             size = 0.01, 
             stroke = 0, 
             alpha = 0) + 
  geom_point(data = subdist_df_dec,
             aes(x = risk_dec, y = obs_dec),
             shape = 23,
             stroke = 0.1,
             fill = "gold") + 
  scale_y_continuous(breaks = seq(0, 1, 0.2), limits = c(0, 1)) +
  scale_x_continuous(breaks = seq(0, 1, 0.2), limits = c(0, 1)) +
  theme_bw() + 
  labs(x = "Predicted risks", y = "Observed outcome proportions") + 
  coord_fixed(ratio = 1, expand = TRUE)  -> p1a

# A 5 años----
horizon <- 5

vdata <- imp.datosA %>% 
  mutate(risk2y = kfre_pr(imp.datosA, horizon = 2), 
         risk5y = kfre_pr(imp.datosA, horizon = 5)) |> 
  select(.imp, .id, risk2y, risk5y, time5y, eventd5y, time, eventd) |> 
  mutate(pred = risk5y) |> 
  select(.imp, .id, time, eventd, pred) |> 
  mutate(cll_pred = log(-log(1 - pred)))

subdist_list <- future_map(1:max(vdata$.imp),
                           process_imp_cal_plot, 
                           vdata = vdata, 
                           primary_event = primary_event, 
                           horizon = horizon, 
                           type = "subdist_hazard", 
                           n_internal_knots = 5,
                           .options = furrr_options(seed = 123, 
                                                    packages = c("riskRegression", 
                                                                 "survival", 
                                                                 "splines", 
                                                                 "cmprsk",
                                                                 "tidyverse")), 
                           .progress = TRUE)

subdist_df <- bind_rows(subdist_list) |>  
  filter(.imp != 0) |> 
  arrange(.imp, .id)

rio::export(subdist_df, here("Data", "Tidy", "subdist_df_3a4_5y.rds"))

# 5 knots seems to give somewhat equivalent graph to pseudo method with bw = 0.05
vdata_stack <- vdata |> 
  filter(.imp != 0)

n_internal_knots <- 5

rcs_vdata <- ns(vdata_stack$cll_pred, df = n_internal_knots + 1)

colnames(rcs_vdata) <- paste0("basisf_", colnames(rcs_vdata))
# vdata_bis <- cbind.data.frame(vdata_filt, rcs_vdata)

vdata_stack <- vdata_stack |> 
  bind_cols(as.data.frame(rcs_vdata))

# Use subdistribution hazards (Fine-Gray) model
form_fgr <- reformulate(
  termlabels = colnames(rcs_vdata),
  response = "Hist(time, eventd)")

# Regress subdistribution of event of interest on cloglog of estimated risks
calib_fgr <- FGR(
  formula = form_fgr,
  cause = primary_event,
  data = vdata_stack, 
  variance = FALSE
)

obs <- predict(calib_fgr, times = horizon, newdata = vdata_stack)

subdist_df2 <- vdata_stack |>
   mutate(obs_stack = obs, 
          risk = pred, 
          deciles_risk = quantcut(risk, seq(0, 1, by = 0.1)))

# Crea datos con predicciones agrupadas por deciles
subdist_df_dec <- subdist_df2 |>
  group_by(deciles_risk) |>
  summarize(
    risk_dec = mean(risk),
    obs_dec = mean(obs_stack))

# Grafico de calibracion
ggplot() +
  geom_abline(intercept = 0, slope = 1, colour = "red", linetype = 2) + 
  geom_line(data = subdist_df |> arrange(risk),
            aes(x = risk, y = obs, group = .imp),
            alpha = 0.1, color = "#38B8F7") +
  geom_line(data = subdist_df2 |> arrange(risk),
            aes(x = risk, y = obs_stack),
            alpha = 1, color = "blue") +
  geom_point(data = subdist_df |> arrange(risk), 
             aes(x = risk, y = obs), 
             size = 0.01, 
             stroke = 0, 
             alpha = 0) + 
  geom_point(data = subdist_df_dec,
             aes(x = risk_dec, y = obs_dec),
             shape = 23,
             stroke = 0.1,
             fill = "gold") + 
  scale_y_continuous(breaks = seq(0, 1, 0.2), limits = c(0, 1)) +
  scale_x_continuous(breaks = seq(0, 1, 0.2), limits = c(0, 1)) +
  theme_bw() + 
  labs(x = "Predicted risks", y = "Observed outcome proportions") + 
  coord_fixed(ratio = 1, expand = TRUE)  -> p2a

# Seleccion del grupo: Stages 3b-4----

primary_event <- 1

# A 2 años----
vdata <- imp.datosB %>% 
  mutate(risk2y = kfre_pr(imp.datosB, horizon = 2), 
         risk5y = kfre_pr(imp.datosB, horizon = 5)) |> 
  select(.imp, .id, risk2y, risk5y, time5y, eventd5y, time, eventd) |> 
  mutate(pred = risk2y) |> 
  select(.imp, .id, time, eventd, pred) |> 
  mutate(cll_pred = log(-log(1 - pred)))

horizon <- 2
subdist_list <- future_map(1:max(vdata$.imp),
                           process_imp_cal_plot, 
                           vdata = vdata, 
                           primary_event = primary_event, 
                           horizon = horizon, 
                           type = "subdist_hazard", 
                           n_internal_knots = 5,
                           .options = furrr_options(seed = 123, 
                                                    packages = c("riskRegression", 
                                                                 "survival", 
                                                                 "splines", 
                                                                 "cmprsk",
                                                                 "tidyverse")), 
                           .progress = TRUE)

subdist_df <- bind_rows(subdist_list) |>  
  filter(.imp != 0) |> 
  arrange(.imp, .id)

rio::export(subdist_df, here("Data", "Tidy", "subdist_df_3b4_2y.rds"))

# 5 knots seems to give somewhat equivalent graph to pseudo method with bw = 0.05
vdata_stack <- vdata |> 
  filter(.imp != 0)

n_internal_knots <- 5

rcs_vdata <- ns(vdata_stack$cll_pred, df = n_internal_knots + 1)

colnames(rcs_vdata) <- paste0("basisf_", colnames(rcs_vdata))
# vdata_bis <- cbind.data.frame(vdata_filt, rcs_vdata)

vdata_stack <- vdata_stack |> 
  bind_cols(as.data.frame(rcs_vdata))

# Use subdistribution hazards (Fine-Gray) model
form_fgr <- reformulate(
  termlabels = colnames(rcs_vdata),
  response = "Hist(time, eventd)")

# Regress subdistribution of event of interest on cloglog of estimated risks
calib_fgr <- FGR(
  formula = form_fgr,
  cause = primary_event,
  data = vdata_stack, 
  variance = FALSE
)

obs <- predict(calib_fgr, times = horizon, newdata = vdata_stack)

subdist_df2 <- vdata_stack |>
   mutate(obs_stack = obs, 
          risk = pred, 
          deciles_risk = quantcut(risk, seq(0, 1, by = 0.1)))

# Crea datos con predicciones agrupadas por deciles
subdist_df_dec <- subdist_df2 |>
  group_by(deciles_risk) |>
  summarize(
    risk_dec = mean(risk),
    obs_dec = mean(obs_stack))

# Grafico de calibracion
ggplot() +
  geom_abline(intercept = 0, slope = 1, colour = "red", linetype = 2) + 
  geom_line(data = subdist_df |> arrange(risk),
            aes(x = risk, y = obs, group = .imp),
            alpha = 0.1, color = "#38B8F7") +
  geom_line(data = subdist_df2 |> arrange(risk),
            aes(x = risk, y = obs_stack),
            alpha = 1, color = "blue") +
  geom_point(data = subdist_df |> arrange(risk), 
             aes(x = risk, y = obs), 
             size = 0.01, 
             stroke = 0, 
             alpha = 0) + 
  geom_point(data = subdist_df_dec,
             aes(x = risk_dec, y = obs_dec),
             shape = 23,
             stroke = 0.1,
             fill = "gold") + 
  scale_y_continuous(breaks = seq(0, 1, 0.2), limits = c(0, 1)) +
  scale_x_continuous(breaks = seq(0, 1, 0.2), limits = c(0, 1)) +
  theme_bw() + 
  labs(x = "Predicted risks", y = "Observed outcome proportions") + 
  coord_fixed(ratio = 1, expand = TRUE)  -> p1b


# A 5 años----
vdata <- imp.datosB %>% 
  mutate(risk2y = kfre_pr(imp.datosB, horizon = 2), 
         risk5y = kfre_pr(imp.datosB, horizon = 5)) |> 
  select(.imp, .id, risk2y, risk5y, time5y, eventd5y, time, eventd) |> 
  mutate(pred = risk5y) |> 
  select(.imp, .id, time, eventd, pred) |> 
  mutate(cll_pred = log(-log(1 - pred)))

horizon <- 5
subdist_list <- future_map(1:max(vdata$.imp),
                           process_imp_cal_plot, 
                           vdata = vdata, 
                           primary_event = primary_event, 
                           horizon = horizon, 
                           type = "subdist_hazard", 
                           n_internal_knots = 5,
                           .options = furrr_options(seed = 123, 
                                                    packages = c("riskRegression", 
                                                                 "survival", 
                                                                 "splines", 
                                                                 "cmprsk",
                                                                 "tidyverse")), 
                           .progress = TRUE)

subdist_df <- bind_rows(subdist_list) |>  
  filter(.imp != 0) |> 
  arrange(.imp, .id)

rio::export(subdist_df, here("Data", "Tidy", "subdist_df_3b4_5y.rds"))

# 5 knots seems to give somewhat equivalent graph to pseudo method with bw = 0.05
vdata_stack <- vdata |> 
  filter(.imp != 0)

n_internal_knots <- 5

rcs_vdata <- ns(vdata_stack$cll_pred, df = n_internal_knots + 1)

colnames(rcs_vdata) <- paste0("basisf_", colnames(rcs_vdata))
# vdata_bis <- cbind.data.frame(vdata_filt, rcs_vdata)

vdata_stack <- vdata_stack |> 
  bind_cols(as.data.frame(rcs_vdata))

# Use subdistribution hazards (Fine-Gray) model
form_fgr <- reformulate(
  termlabels = colnames(rcs_vdata),
  response = "Hist(time, eventd)")

# Regress subdistribution of event of interest on cloglog of estimated risks
calib_fgr <- FGR(
  formula = form_fgr,
  cause = primary_event,
  data = vdata_stack, 
  variance = FALSE
)

obs <- predict(calib_fgr, times = horizon, newdata = vdata_stack)

subdist_df2 <- vdata_stack |>
   mutate(obs_stack = obs, 
          risk = pred, 
          deciles_risk = quantcut(risk, seq(0, 1, by = 0.1)))

# Crea datos con predicciones agrupadas por deciles
subdist_df_dec <- subdist_df2 |>
  group_by(deciles_risk) |>
  summarize(
    risk_dec = mean(risk),
    obs_dec = mean(obs_stack))

# Grafico de calibracion
ggplot() +
  geom_abline(intercept = 0, slope = 1, colour = "red", linetype = 2) + 
  geom_line(data = subdist_df |> arrange(risk),
            aes(x = risk, y = obs, group = .imp),
            alpha = 0.1, color = "#38B8F7") +
  geom_line(data = subdist_df2 |> arrange(risk),
            aes(x = risk, y = obs_stack),
            alpha = 1, color = "blue") +
  geom_point(data = subdist_df |> arrange(risk), 
             aes(x = risk, y = obs), 
             size = 0.01, 
             stroke = 0, 
             alpha = 0) + 
  geom_point(data = subdist_df_dec,
             aes(x = risk_dec, y = obs_dec),
             shape = 23,
             stroke = 0.1,
             fill = "gold") + 
  scale_y_continuous(breaks = seq(0, 1, 0.2), limits = c(0, 1)) +
  scale_x_continuous(breaks = seq(0, 1, 0.2), limits = c(0, 1)) +
  theme_bw() + 
  labs(x = "Predicted risks", y = "Observed outcome proportions") + 
  coord_fixed(ratio = 1, expand = TRUE)  -> p2b

p1a <- p1a + 
  labs(title = "CKD Stages 3a-3b-4\n(2 year KFRE)") + 
  theme(plot.title = element_text(hjust = 0.5))
p2a <- p2a + labs(title = "CKD Stages 3a-3b-4\n(5 year KFRE)") + 
  theme(plot.title = element_text(hjust = 0.5))
p1b <- p1b + labs(title = "CKD Stages 3b-4\n(2 year KFRE)") + 
  theme(plot.title = element_text(hjust = 0.5))
p2b <- p2b + labs(title = "CKD Stages 3b-4\n(5 year KFRE)") + 
  theme(plot.title = element_text(hjust = 0.5))

plot_calibration <- (p1a | p2a) / (p1b | p2b) + plot_annotation(tag_levels = 'A')

ggsave(filename = "Plot_Calibration_imputed.png", 
       device = "png", 
       plot = plot_calibration, 
       path = here("Figures"), 
       scale = 2, 
       width = 12, 
       height = 12,
       units = "cm", 
       dpi = 600)
```

### Fig 3

```{r}
#| label: fig-loess-pseudo-ggpplot
#| fig.width: 7
#| fig.height: 7
#| fig.align: center
#| fig-cap: "Calibration curves for each group and prediction horizon"
knitr::include_graphics(here("Figures", "Plot_Calibration_imputed.png"))
```


## Extra


```{r}
# # Calibration plot (pseudo-obs approach) ----------------------------------
# # First compute riskRegression::Score()
# # Ejecutar la función en paralelo para cada grupo de imputación
# pseudos_list <- future_map(0:max(vdata$.imp),
#                            process_imp_cal_plot, 
#                            vdata = vdata, 
#                            primary_event = primary_event, 
#                            horizon = horizon, 
#                            type = "pseudoval_loess", 
#                            .options = furrr_options(seed = 123, 
#                                                     packages = c("riskRegression", 
#                                                                  "survival", 
#                                                                  "tidyverse")), 
#                            .progress = TRUE)
# 
# pseudos_df <- bind_rows(pseudos_list) |> 
#   arrange(.imp, .id)
# 
# # pseudos.imp <- as.mids(pseudos_df)
# # pseudos.imp$loggedEvents
# 
# pseudos_df <- pseudos_df %>% 
#   filter(.imp != 0) |> 
#   arrange(risk)
# 
# # Definimos una función que ajusta el modelo y devuelve las predicciones
# model_and_predict <- function(data) {
#   # model <- lm(pseudovalue ~ ns(risk, df = 6), data = data)
#   model <- loess(pseudovalue ~ risk, data = data, degree = 1)
#   predict(model, newdata = data)
# }
# 
# # Suponiendo que 'pseudos_df' es tu dataframe
# pseudos_df <- pseudos_df %>%
#   as_tibble() %>%
#   group_by(.imp) %>%
#   group_split()  # Divide el dataframe en una lista de dataframes por grupo de imputación
# 
# # Aplica la función en paralelo y combina los resultados
# predictions <- future_map(pseudos_df, model_and_predict,
#                           .options = furrr_options(seed = 123, 
#                                                    packages = c("splines")), 
#                           .progress = TRUE)
# 
# # Añade las predicciones de vuelta al dataframe original
# pseudos_df <- bind_rows(pseudos_df)  # Si se necesita combinar nuevamente en un solo dataframe
# 
# # Crea datos con predicciones suavizadas
# pseudos_df2 <- pseudos_df |> 
#   mutate(
#     obs = unlist(predictions),    # Añade las predicciones como una nueva columna
#     deciles_risk = quantcut(risk, seq(0, 1, by = 0.001))  # Añade cuantiles de riesgo stacked
#   )
# 
# # Modelo con todos los datos stacked
# # model_stack <- lm(pseudovalue ~ ns(risk, df = 6), data = pseudos_df2)
# tic()
# # model <- loess(pseudovalue ~ risk, data = pseudos_df2, degree = 1)
# toc()
# 
# pseudos_df2 <- pseudos_df2 |> 
#    mutate(obs_stack = predict(model_stack, newdata = pseudos_df2))
# 
# # Crea datos con predicciones agrupadas por deciles
# pseudos_df_dec <- pseudos_df2 |> 
#   group_by(deciles_risk) |> 
#   summarize(risk_dec = mean(risk), 
#          obs_dec = mean(obs))
# 
# # Grafico de calibracion
# ggplot() +
#   geom_abline(intercept = 0, slope = 1, colour = "red", linetype = 2) + 
#   geom_line(data = pseudos_df2 |> arrange(risk), 
#             aes(x = risk, y = obs, group = .imp), 
#             alpha = 0.1) + 
#   geom_line(data = pseudos_df2 |> arrange(risk), 
#             aes(x = risk, y = obs_stack), 
#             alpha = 1, color = "blue") + 
#   # geom_point(aes(x = risk, y = obs), size = 0.01, alpha = 0) + 
#   scale_y_continuous(breaks = seq(0, 1, 0.2), limits = c(-0.1, 1)) +
#   scale_x_continuous(breaks = seq(0, 1, 0.2), limits = c(-0.1, 1)) +
#   theme_bw() + 
#   xlab("Predicted risks") + 
#   ylab("Observed outcome proportions") + 
#   coord_fixed(ratio = 1, expand = TRUE) + 
#   geom_point(data = pseudos_df_dec, 
#              aes(x = risk_dec, y = obs_dec), 
#              shape = 23, 
#              stroke = 1,
#              fill = "gold") -> p1
# 
# # ggMarginal(p1, type = "histogram", fill = "purple") -> p1a
# 
# p1
```

## Ticket de Reprocubilidad

```{r}
#| label: repro_ticket
#| column: page
#| echo: true
sessionInfo()
```

