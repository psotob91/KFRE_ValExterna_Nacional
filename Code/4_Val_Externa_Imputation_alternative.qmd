---
title: "4 Codigo Reproducible: Rendimiento de Validacion Externa de ecuaciones originales - Recalibración de modelo KFRE para predecir falla renal en asegurados de EsSalud"
author: "Percy Soto Becerra"
format: 
  html:
   theme: cerulean
   toc: true
   number-sections: true
   df-print: paged
   page-layout: full
   embed-resources: true
   code-fold: true
execute: 
  warning: false
  message: false
---

## Introduction 

This document presents the code and results of the main analysis shown in the article.

## Setup

```{r}
#| label: load-packages
#| include: true

rm(list = ls())

# Use pacman to check whether packages are installed, if not load
if (!require("pacman")) install.packages("pacman")
library(pacman)

# Unload all package to begin in a session with only base packages
pacman::p_unload(all)

# Install packages
pacman::p_load(
  here, 
  skimr, 
  survival,
  survminer, 
  rms,
  cmprsk,
  riskRegression,
  mstate,
  pseudo,
  pec,
  plotrix,
  knitr,
  splines,
  kableExtra,
  flextable,
  gtsummary,
  boot,
  tidyverse,
  rsample,
  gridExtra,
  webshot, 
  patchwork,
  survival, 
  ggsci, 
  cowplot, 
  scales, 
  patchwork, 
  labelled, 
  glue, 
  dcurves, 
  broom, 
  downlit, 
  xml2, 
  gghalves, 
  devtools, 
  htmltools, 
  gghalves, 
  ggtext, 
  DiagrammeR, 
  gt, 
  janitor, 
  VIM, 
  PerformanceAnalytics, 
  mice, 
  rms, 
  naniar, 
  DescTools, 
  gtools, 
  ggExtra, 
  furrr, 
  future, 
  ggmice,
  parallel,
  tictoc, 
  rio,
  tidymodels
)

if (!require("impstep")) remotes::install_github("bgravesteijn/impstep", force = TRUE)
if (!require("smplot2")) devtools::install_github('smin95/smplot2', force = TRUE)
# You will need Rtools to install packages from Github on Windows
# `devtools` with throw an informative error if Rtools is not found
# if (!"devtools" %in% installed.packages()) install.packages("devtools")
# if (!require("smplot2")) devtools::install_github("jesse-smith/futuremice")

library(impstep)

## Revisar:; https://amices.org/ggmice/index.html
```

## Cargar datos

```{r}
# Import data
data_impA <- readRDS(here::here("Data", "Tidy", "data_impA.rds")) 
imp.datosA <- complete(data_impA, action = "long", include = TRUE)
rm(data_impA)
gc()
```

## Cargar funciones

```{r}
source(here("Code", "source", "kfre_pi.R"))
source(here("Code", "source", "kfre_pr.R"))
source(here("Code", "source", "oe_ratio.R"))
source(here("Code", "source", "calibration_intercept.R"))
source(here("Code", "source", "calibration_slope.R"))
source(here("Code", "source", "auc.R"))
source(here("Code", "source", "auc_brier_boot.R"))
source(here("Code", "source", "validate.mids.R"))
source(here("Code", "source", "pool.validate.mids.R"))
source(here("Code", "source", "pool.auc.mids.R"))
source(here("Code", "source", "process_imp_cal_plot.R"))
source(here("Code", "source", "predict.mira.R"))
source(here("Code", "source", "performance_measures.R"))
source(here("Code", "source", "tidy_performance_stack.R"))    
source(here("Code", "source", "tidy_pool.R")) 
source(here("Code", "source", "process_imp_cal_plot.R")) 
```


## Configurar cores para parallel processing

```{r}
n_cores <- detectCores()
n_cores <- 10

# Evaluate futures in parallel - max of two workers to avoid hogging resources
future::plan("multisession", workers = n_cores)
```

## Semilla

```{r}
seed <- 2014
```

## Pre-procesar

```{r}
imp.datosA <- imp.datosA |> 
  mutate(risk2y = kfre_pr(imp.datosA, 2),
         risk5y = kfre_pr(imp.datosA, 5), 
         eventdf = factor(eventd)) |> 
  select(.imp, .id, time, eventd, eventdf, risk2y, risk5y) |>  
  filter(.imp != 0) 
```


## Predictive Performance

### Calibration and Discrimination Measures

```{r}
future::plan("multisession", workers = n_cores)
results_stack3a4_2y <- tidy_performance_stack(imp.datosA, 
                                  horizon = 2, 
                                  primary_event = 1, 
                                  pred = "risk2y",
                                  seed = seed, 
                                  n_cores = n_cores)

rio::export(results_stack3a4_2y , here("Data", "Tidy", 
                                       "res_valext__kfre_orig_stack3a4_2y.rds"))

future::plan("multisession", workers = n_cores)
results_stack3a4_5y <- tidy_performance_stack(imp.datosA, 
                                  horizon = 5, 
                                  primary_event = 1, 
                                  pred = "risk5y",
                                  seed = seed, 
                                  n_cores = n_cores)

rio::export(results_stack3a4_5y, here("Data", "Tidy", 
                                      "res_valext_kfre_orig_stack3a4_5y.rds"))
```

```{r}
res_pool1 <- tidy_pool(results_stack3a4_2y) 

res_pool1 |> 
  kbl() |> 
  kable_classic(full_width = T, html_font = "Cambria")
```

```{r}
res_pool2 <- tidy_pool(results_stack3a4_5y) 

res_pool2 |> 
  kbl() |> 
  kable_classic(full_width = T, html_font = "Cambria")
```

```{r}
tab_res_2y <- res_pool1 |> 
  select(term, estimate, ll, ul) |> 
  mutate(
    across(c(estimate, ll, ul), ~ if_else(term == "Log OE ratio", exp(.x), .x)), 
    across(c(estimate, ll, ul), ~ if_else(term == "Logit AUC", exp(.x) / (1  + exp(.x)), .x)), 
    term = if_else(term == "Log OE ratio", "OE ratio", term), 
    term = if_else(term == "Logit AUC", "AUC", term), 
    across(c(estimate, ll, ul), ~ if_else(term %in% 
                                            c("Average predicted risk", 
                                              "Overall observerd risk", 
                                              "OE difference"), 100 * .x, .x)), 
    across(c(estimate, ll, ul), ~ round(.x, 2)), 
    measures = case_when(term == "Average predicted risk" ~ str_glue("{estimate}%"), 
                       term %in% c("Overall observerd risk", "OE difference") ~ str_glue("{estimate}% ({ll}% to {ul}%)"),
                       TRUE ~ str_glue("{estimate} ({ll} to {ul})")
                       )
    ) |> 
  select(term, measures) |> 
  mutate(grupo = c(rep("Calibration", 6), "Discrimination", "Overall performance"), 
         year = "2 years")

tab_res_5y <- res_pool2 |> 
  select(term, estimate, ll, ul) |> 
  mutate(
    across(c(estimate, ll, ul), ~ if_else(term == "Log OE ratio", exp(.x), .x)), 
    across(c(estimate, ll, ul), ~ if_else(term == "Logit AUC", exp(.x) / (1  + exp(.x)), .x)), 
    term = if_else(term == "Log OE ratio", "OE ratio", term), 
    term = if_else(term == "Logit AUC", "AUC", term), 
    across(c(estimate, ll, ul), ~ if_else(term %in% 
                                            c("Average predicted risk", 
                                              "Overall observerd risk", 
                                              "OE difference"), 100 * .x, .x)), 
    across(c(estimate, ll, ul), ~ round(.x, 2)), 
    measures = case_when(term == "Average predicted risk" ~ str_glue("{estimate}%"), 
                       term %in% c("Overall observerd risk", "OE difference") ~ str_glue("{estimate}% ({ll}% to {ul}%)"),
                       TRUE ~ str_glue("{estimate} ({ll} to {ul})")
                       )
    ) |> 
  select(term, measures) |> 
  mutate(grupo = c(rep("Calibration", 6), "Discrimination", "Overall performance"), 
         year = "5 years")

tab_res0 <- tab_res_2y |>
  bind_rows(tab_res_5y)

tab_res0 |> 
  as_grouped_data(groups = "year") |> 
  as_grouped_data(groups = "grupo") |> 
  flextable::as_flextable(hide_grouplabel = TRUE) |> 
  autofit() |> 
  set_header_labels(
    year = "Time horizon", 
    term = "Performance measure", 
    measures = "Original KFRE"
  ) |>  
  bold(j = 1) |> 
  set_caption("Table. Performance measures of KFRE in the external dataset of patients with CKD Stages 3a-4") |>  
  theme_booktabs() |>   
  bold(bold = TRUE, part = "header") -> table_perf_final

table_perf_final %>% 
  flextable::save_as_docx(path = here("Tables/Table_Imputed_Performance_Modelo_Original.docx"))

table_perf_final
```

```{r}
rm(list=ls()[! ls() %in% c("imp.datosA","vdata", "primary_event", "horizon", 
                           "process_imp_cal_plot", "seed", "n_cores")])
gc()
```

### Moderate calibration: Calibration curves lowess based on subdistributional hazards

```{r}
primary_event <- 1

n_internal_knots <- 5

# Seleccion del grupo: Stages 3-4----

# A 2 años----
horizon <- 2

vdata <- imp.datosA %>% 
  rename(pred = risk2y) |> 
  select(.imp, .id, time, eventd, pred) |> 
  mutate(cll_pred = log(-log(1 - pred)))

future::plan("multisession", workers = n_cores)

subdist_df_imp <- future_map(1:max(vdata$.imp),
                         process_imp_cal_plot, 
                         vdata = vdata, 
                         primary_event = primary_event, 
                         horizon = horizon, 
                         type = "subdist_hazard", 
                         n_internal_knots = n_internal_knots,
                         .options = furrr_options(seed = seed, 
                                                  packages = c("riskRegression", 
                                                               "survival", 
                                                               "splines", 
                                                               "cmprsk",
                                                               "tidyverse")), 
                         .progress = TRUE) 

subdist_df_imp <- subdist_df_imp |> 
  bind_rows() |>  
  arrange(risk)

# 5 knots seems to give somewhat equivalent graph to pseudo method with bw = 0.05
rcs_vdata <- ns(vdata$cll_pred, df = n_internal_knots + 1)

colnames(rcs_vdata) <- paste0("basisf_", colnames(rcs_vdata))
# vdata_bis <- cbind.data.frame(vdata_filt, rcs_vdata)

vdata <- vdata |> 
  bind_cols(as.data.frame(rcs_vdata))

# Use subdistribution hazards (Fine-Gray) model
form_fgr <- reformulate(
  termlabels = colnames(rcs_vdata),
  response = "Hist(time, eventd)")

# Regress subdistribution of event of interest on cloglog of estimated risks
calib_fgr <- FGR(
  formula = form_fgr,
  cause = primary_event,
  data = vdata, 
  variance = FALSE, 
  y = FALSE
)

obs <- predict(calib_fgr, times = horizon, newdata = vdata)

subdist_df_stack <- vdata |>
  rename(risk = pred) |> 
  mutate(obs_stack = obs, 
         deciles_risk = quantcut(risk, seq(0, 1, by = 0.1))) |> 
  arrange(risk)

# Crea datos con predicciones agrupadas por deciles
subdist_df_dec <- subdist_df_stack |>
  group_by(deciles_risk) |>
  summarize(
    risk_dec = mean(risk),
    obs_dec = mean(obs_stack)) |> 
  arrange(deciles_risk)

rio::export(subdist_df_imp, here("Data", "Tidy", "subdist_df_imput_3a4_2y.rds"))
rio::export(subdist_df_stack, here("Data", "Tidy", "subdist_df_stack_3a4_2y.rds"))
rio::export(subdist_df_dec, here("Data", "Tidy", "subdist_df_dec_3a4_2y.rds"))

# Grafico de calibracion
ggplot() +
  geom_abline(intercept = 0, slope = 1, colour = "red", linetype = 2) + 
  geom_line(data = subdist_df_stack, aes(x = risk, y = obs_stack),
            alpha = 1, color = "blue") +
  geom_point(data = subdist_df_dec,
             aes(x = risk_dec, y = obs_dec),
             shape = 23,
             stroke = 0.1,
             fill = "gold") + 
  scale_y_continuous(breaks = seq(0, 1, 0.2), limits = c(0, 1)) +
  scale_x_continuous(breaks = seq(0, 1, 0.2), limits = c(0, 1)) +
  theme_bw() + 
  labs(x = "Predicted risks", y = "Observed outcome proportions") + 
  # geom_rug(data = subdist_df_stack,
  #          aes(x = risk, y = obs_stack),
  #          alpha = 0.1) +
  coord_fixed(ratio = 1, expand = TRUE)  -> plot_mod0_2y

# Grafico de calibracion con curvas imputadas
plot_mod0_2y + 
  geom_line(data = subdist_df_imp, aes(x = risk, y = obs, group = .imp),
            alpha = 0.1, color = "#38B8F7") -> plot_mod0_imp_2y

gc()

# A 5 años----
horizon <- 5

vdata <- imp.datosA %>% 
  rename(pred = risk5y) |> 
  select(.imp, .id, time, eventd, pred) |> 
  mutate(cll_pred = log(-log(1 - pred))) 

future::plan("multisession", workers = n_cores)

subdist_df_imp <- future_map(1:max(vdata$.imp),
                         process_imp_cal_plot, 
                         vdata = vdata, 
                         primary_event = primary_event, 
                         horizon = horizon, 
                         type = "subdist_hazard", 
                         n_internal_knots = n_internal_knots,
                         .options = furrr_options(seed = seed, 
                                                  packages = c("riskRegression", 
                                                               "survival", 
                                                               "splines", 
                                                               "cmprsk",
                                                               "tidyverse")), 
                         .progress = TRUE) 

subdist_df_imp <- subdist_df_imp |> 
  bind_rows() |>  
  arrange(risk)

# 5 knots seems to give somewhat equivalent graph to pseudo method with bw = 0.05
rcs_vdata <- ns(vdata$cll_pred, df = n_internal_knots + 1)

colnames(rcs_vdata) <- paste0("basisf_", colnames(rcs_vdata))
# vdata_bis <- cbind.data.frame(vdata_filt, rcs_vdata)

vdata <- vdata |> 
  bind_cols(as.data.frame(rcs_vdata))

# Use subdistribution hazards (Fine-Gray) model
form_fgr <- reformulate(
  termlabels = colnames(rcs_vdata),
  response = "Hist(time, eventd)")

# Regress subdistribution of event of interest on cloglog of estimated risks
calib_fgr <- FGR(
  formula = form_fgr,
  cause = primary_event,
  data = vdata, 
  variance = FALSE, 
  y = FALSE
)

obs <- predict(calib_fgr, times = horizon, newdata = vdata)

subdist_df_stack <- vdata |>
  rename(risk = pred) |> 
  mutate(obs_stack = obs, 
         deciles_risk = quantcut(risk, seq(0, 1, by = 0.1))) |> 
  arrange(risk)

# Crea datos con predicciones agrupadas por deciles
subdist_df_dec <- subdist_df_stack |>
  group_by(deciles_risk) |>
  summarize(
    risk_dec = mean(risk),
    obs_dec = mean(obs_stack)) |> 
  arrange(deciles_risk)

rio::export(subdist_df_imp, here("Data", "Tidy", "subdist_df_imput_3a4_2y.rds"))
rio::export(subdist_df_stack, here("Data", "Tidy", "subdist_df_stack_3a4_2y.rds"))
rio::export(subdist_df_dec, here("Data", "Tidy", "subdist_df_dec_3a4_2y.rds"))

# Grafico de calibracion
ggplot() +
  geom_abline(intercept = 0, slope = 1, colour = "red", linetype = 2) + 
  geom_line(data = subdist_df_stack, aes(x = risk, y = obs_stack),
            alpha = 1, color = "blue") +
  geom_point(data = subdist_df_dec,
             aes(x = risk_dec, y = obs_dec),
             shape = 23,
             stroke = 0.1,
             fill = "gold") + 
  scale_y_continuous(breaks = seq(0, 1, 0.2), limits = c(0, 1)) +
  scale_x_continuous(breaks = seq(0, 1, 0.2), limits = c(0, 1)) +
  theme_bw() + 
  labs(x = "Predicted risks", y = "Observed outcome proportions") + 
  # geom_rug(data = subdist_df_stack,
  #          aes(x = risk, y = obs_stack),
  #          alpha = 0.1) +
  coord_fixed(ratio = 1, expand = TRUE)  -> plot_mod0_5y

# Grafico de calibracion con curvas imputadas
plot_mod0_5y + 
  geom_line(data = subdist_df_imp, aes(x = risk, y = obs, group = .imp),
            alpha = 0.1, color = "#38B8F7") -> plot_mod0_imp_5y

## Grafico final
plot_mod0_2y <- plot_mod0_2y + 
  labs(title = "Modelo Original\n(2 year KFRE)") + 
  theme(plot.title = element_text(hjust = 0.5))

plot_mod0_5y <- plot_mod0_5y + 
  labs(title = "Modelo Original\n(5 year KFRE)") + 
  theme(plot.title = element_text(hjust = 0.5))

plot_mod0_imp_2y <- plot_mod0_imp_2y + 
  labs(title = "Modelo Original\n(2 year KFRE)") + 
  theme(plot.title = element_text(hjust = 0.5))

plot_mod0_imp_5y <- plot_mod0_imp_5y + 
  labs(title = "Modelo Original\n(5 year KFRE)") + 
  theme(plot.title = element_text(hjust = 0.5))

plot_cal_mod0 <- plot_mod0_2y / plot_mod0_5y

export(plot_mod0_2y, here("Data", "Tidy", "plot_mod0_2y.rds"))
export(plot_mod0_5y, here("Data", "Tidy", "plot_mod0_5y.rds"))
export(plot_cal_mod0, here("Data", "Tidy", "plot_cal_mod0.rds"))

export(plot_mod0_imp_2y, here("Data", "Tidy", "plot_mod0_imp_2y.rds"))
export(plot_mod0_imp_5y, here("Data", "Tidy", "plot_mod0_imp_5y.rds"))

ggsave(filename = "Plot_Calibration_imputed.png", 
       device = "png", 
       plot = plot_cal_mod0, 
       path = here("Figures"), 
       scale = 2, 
       width = 12, 
       height = 12,
       units = "cm", 
       dpi = 600)

gc()
```

```{r}
#| fig.align: center
#| fig-cap: "Calibration curves for each group and prediction horizon"
knitr::include_graphics(here("Figures", "Plot_Calibration_imputed.png"))
```

## Ticket de Reprocubilidad

```{r}
#| label: repro_ticket
#| column: page
#| echo: true
sessionInfo()
```

